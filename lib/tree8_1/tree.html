<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Collapsible tree in reusable format using D3 v4</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <!-- <link rel="stylesheet" href="index.css"> -->
    <!-- <script src="index.js"></script> -->
</head>
<style>
  .node circle {
    fill: #fff;
    stroke: steelblue;
    stroke-width: 3px;
  }

  .node text {
      font: 12px sans-serif;
  }

  .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
  }

</style>
<script>
	function tree() {
  var data,
      i = 0,
      duration = 500,
      margin = {top: 20, right: 10, bottom: 30, left: 30},
    width = 1280 - margin.left - margin.right,
      height = 960 - margin.top - margin.bottom,
      update;

  function chart(selection){
      selection.each(function() {
        height = height - margin.top - margin.bottom;
        width = width - margin.left - margin.right;
          // append the svg object to the selection
          var svg = selection.append('svg')
              .attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom)
            .append('g')
              .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

          // declares a tree layout and assigns the size of the tree
          var treemap = d3.tree().size([height, width]);

          // assign parent, children, height, depth
          var root = d3.hierarchy(data, function(d) { return d.children });
          root.x0 = height / 2; // left edge of the rectangle
          root.y0 = 0; // top edge of the triangle

        // collapse after the second level
        root.children.forEach(collapse);

        update(root);

        // collapse the node and all it's children
        function collapse(d) {
          if (d.children) {
            d._children = d.children;
            d._children.forEach(collapse);
            d.children = null;
          }
        }

        function update(source) {

          // assigns the x and y position for the nodes
          var treeData = treemap(root);

          // compute the new tree layout
          var nodes = treeData.descendants(),
              links = treeData.descendants().slice(1);

          // normalise for fixed depth
          nodes.forEach(function(d) { d.y = d.depth * 180; });

          // ****************** Nodes section ***************************

          // update the nodes ...
          var node = svg.selectAll('g.node')
            .data(nodes, function(d) { return d.id || (d.id = ++i); });

          // Enter any new modes at the parent's previous position.
          var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr('transform', function(d) {
              return 'translate(' + (source.y0 + margin.top) + ',' + (source.x0 + margin.left) + ')';
            })
            .on('click', click);

          // add circle for the nodes
          nodeEnter.append('circle')
            .attr('class', 'node')
            .attr('r', 1e-6)
            .style('fill', function(d) {
              // console.log(d);
              return d._children ? 'lightsteelblue' : '#fff';
            });

          // add labels for the nodes
          nodeEnter.append('text')
            .attr('dy', '-0.1em')
            .attr('x', function(d) {
              return d.children || d._children ? 0 : 13;
            })
            .attr('y', function(d) {
              return d.children || d._children ? -margin.top : 0;
            })
            .attr('text-anchor', function(d) {
              return d.children || d._children ? 'middle' : 'start';
            })
            .text(function(d) {
              return (d.children || d._children) ? d.data.id.capitalize() : d.data.id;
            }).style('font-size', '16px');

          // add number of children to node circle
          nodeEnter.append('text')
            .attr('x', -8)
            .attr('y', 5)
            .attr('cursor', 'pointer')
            .style('font-size', '12px')
            .text(function(d){
              if (d.children) {// root
                var countAll = 0
                d.children.forEach(function(el) {
                  el._children.forEach(function(eel) {
                    countAll +=  eel._children.length;
                  })
                });
                return countAll; 
              }
              else if (d._children) {
                if (d.depth == 2){
                  return d._children.length;
                } else { //d.depth == 1
                  var countChild = 0
                  d._children.forEach(function(el) {
                    countChild += el._children.length;
                  });
                  return countChild;
                } 
              }
            });
            // .text(function(d) {
            //   if (d.children) return d.childrenlength; 
            //   else if (d._children) d._childrenlength; 
            // });

          // UPDATE
          var nodeUpdate = nodeEnter.merge(node);

          // transition to the proper position for the node
          nodeUpdate.transition().duration(duration)
            .attr('transform', function(d) {
              return 'translate(' + (d.y + margin.top) + ',' + (d.x + margin.left) + ')';
            });

          // update the node attributes and style
          nodeUpdate.select('circle.node').attr('r', 15)

            // .attr('r', function(d) {
            //   if (d.children) {// root
            //     var countAll = 0
            //     d.children.forEach(function(el) {
            //       el._children.forEach(function(eel) {
            //         countAll +=  eel._children.length;
            //       })
            //     });
            //     return countAll / 2; 
            //   }
            //   else if (d._children) {
            //     if (d.depth == 2){
            //       return d._children.length / 2;
            //     } else { //d.depth == 1
            //       var countChild = 0
            //       d._children.forEach(function(el) {
            //         countChild += el._children.length;
            //       });
            //       return countChild / 2;
            //     } 
            //   }
            // })
            .style('fill', function(d) {
              return d._children ? 'lightsteelblue' : '#fff';
            })
            .attr('cursor', 'pointer');

          // remove any exiting nodes
          var nodeExit = node.exit()
            .transition().duration(duration)
            .attr('transform', function(d) {
              return 'translate(' + (source.y + margin.top) + ',' + (source.x + margin.left) + ')';
            })
            .remove();

          // on exit reduce the node circles size to 0
          nodeExit.select('circle')
            .attr('r', 1e-6);

          // on exit reduce the opacity of text labels
          nodeExit.select('text')
            .style('fill-opacity', 1e-6);

          // ****************** links section ***************************

          // update the links
          var link = svg.selectAll('path.link')
            .data(links, function(d) { return d.id });

          // enter any new links at the parent's previous position
          var linkEnter = link.enter().insert('path', 'g')
            .attr('class', 'link')
            .attr('d', function(d) {
              var o = {x: source.x0 + margin.left, y: source.y0 + margin.top};
              return diagonal(o, o);
            });

          // UPDATE
          var linkUpdate = linkEnter.merge(link);

          // transition back to the parent element position
          linkUpdate.transition().duration(duration)
            .attr('d', function(d) { return diagonal(d, d.parent); });

          // remove any exiting links
          var linkExit = link.exit()
            .transition().duration(duration)
            .attr('d', function(d) {
              var o = {x: source.x, y: source.y};
              return diagonal(o, o);
            })
            .remove();

          // store the old positions for transition
          nodes.forEach(function(d) {
            d.x0 = d.x + margin.left;
            d.y0 = d.y + margin.top;
          });

          // creates a curved (diagonal) path from parent to the child nodes
          function diagonal(s, d) {
            path = 'M ' + (s.y + margin.top) + ' ' + (s.x + margin.left) +
                'C ' + ((s.y + d.y + (margin.top * 2)) / 2) + ' ' + (s.x + margin.left) +
                ', ' + ((s.y + d.y + (margin.top * 2)) / 2) + ' ' + (d.x + margin.left) +
                ', ' + (d.y + margin.top) + ' ' + (d.x + margin.left);
            return path;
          }

          // toggle children on click
          function click(d) {
            if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
            update(d);
          }

        }
      });
  }

  chart.width = function(value) {
      if (!arguments.length) return width;
      width = value;
      return chart;
  };

  chart.height = function(value) {
      if (!arguments.length) return height;
      height = value;
      return chart;
  };

  chart.margin = function(value) {
      if (!arguments.length) return margin;
      margin = value;
      return chart;
  };

chart.data = function(value) {
  if (!arguments.length) return data;
  data = value;
  if (typeof updateData === 'function') updateData();
  return chart;
};

String.prototype.capitalize = function() {
  return this.charAt(0).toUpperCase() + this.slice(1).toLowerCase();
};

  return chart;
}
</script>
<body>

<div id="chart"></div>

<script>

  var myTree = tree().height(960).width(1280);

	d3.text('https://raw.githubusercontent.com/CinderD/suggest-features/main/source/tree_feature.tsv', function(error, text) {
		if (error) throw error;
		var table = [{
			name: 'features',
            parent: null
        }];

    ///////// build the tree ///////// 
		var genes = [];
		var drugs = [];
    var jsa = [];
		d3.tsvParseRows(text, function (d, i) {
			if (d[0].startsWith('#')) return;
      // console.log(d[5]); //each row
			if (!drugs.find(function(element){ return element === d[2]; })) {
				table.push({
					name: d[2],
					parent: "features"
				});
				drugs.push(d[2]);
			}

			if (!genes.find(function(element){ return element === d[1]; })) {
				table.push({
					name: d[1],
					parent: d[2]
				});
				genes.push(d[1]);
			}


      if (!jsa.find(function(element){ return element === d[0]; })) {
				table.push({
					name: d[0],
					parent: d[1]
				});
				genes.push(d[0]);
			}
		});

		var root = d3.stratify()
            .id(function(d) { return d.name; })
            .parentId(function (d) { return d.parent; })
            (table);
    
    // console.log(root);

		myTree.data(root);
    ///////// build the tree /////////
		d3.select('#chart')
			.call(myTree);
    });


</script>

</body>
</html>
